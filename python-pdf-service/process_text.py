#!/usr/bin/env python3
"""
Standalone Python script for processing text content
Can be called from Next.js API routes
"""
import sys
import json
import re
from pathlib import Path

def is_watermark_or_header(line):
    """Check if line is a watermark, header, or footer that should be ignored"""
    line_lower = line.lower().strip()
    
    # Common watermark patterns
    watermark_patterns = [
        r'page\s+\d+',
        r'www\.\w+\.com',
        r'http[s]?://\w+',
        r'copyright',
        r'all rights reserved',
        r'confidential',
        r'draft',
        r'preliminary',
        r'version\s+\d+',
        r'generated by',
        r'created by',
        r'pdf',
        r'document',
        r'file',
        r'date:',
        r'time:',
        r'printed on',
        r'printed at',
        r'page \d+ of \d+',
        r'^\d+$',  # Just page numbers
        r'^[^\w]*$',  # Only special characters
        r't\.i\.m\.e\.',  # T.I.M.E. watermark
        r'kabirjaiswal',  # Specific watermark
        r'disclaimer',
        r'instructions',
        r'general instructions',
        r'read the following',
        r'note:',
        r'caution:',
        r'warning:',
    ]
    
    # Check for watermark patterns
    for pattern in watermark_patterns:
        if re.search(pattern, line_lower):
            return True
    
    # Check for very short lines that are likely headers/footers
    if len(line.strip()) < 3:
        return True
    
    # Check for lines with only numbers or special characters
    if re.match(r'^[\d\s\-_\.]+$', line):
        return True
    
    return False

def is_section_header(line):
    """Check if line is a section header using JavaScript logic"""
    line_stripped = line.strip()
    line_lower = line_stripped.lower()
    
    # Skip if it's a watermark
    if is_watermark_or_header(line):
        return False
    
    # JavaScript section keywords
    section_keywords = [
        'english', 'language', 'gk', 'general knowledge', 'current affairs',
        'legal reasoning', 'logical reasoning', 'quantitative', 'mathematics'
    ]
    
    # Check if line contains section keywords AND (length < 50 OR contains 'section')
    for keyword in section_keywords:
        if keyword in line_lower:
            if len(line_stripped) < 50 or 'section' in line_lower:
                # print(f"DEBUG: Section header detected: '{line_stripped}'")
                return True
    
    return False

def is_passage_header(line):
    """Check if line is a passage header"""
    line_stripped = line.strip()
    line_lower = line_stripped.lower()
    
    # Skip if it's a watermark
    if is_watermark_or_header(line):
        return False
    
    # Pattern 1: PASSAGE – I, PASSAGE – II, etc.
    if re.match(r'^PASSAGE[\s–-]*(I|II|III|IV|V|VI|VII|VIII|IX|X)[\s:–-]*', line_stripped, re.IGNORECASE):
        return True
    
    # Pattern 2: PASSAGE – A, PASSAGE – B, etc.
    if re.match(r'^PASSAGE[\s–-]*[A-Z][\s:–-]*', line_stripped, re.IGNORECASE):
        return True
    
    # Pattern 3: Passage 1, Passage 2, etc.
    if re.match(r'^PASSAGE[\s–-]*\d+[\s:–-]*', line_stripped, re.IGNORECASE):
        return True
    
    # Pattern 4: Just "PASSAGE" or "PASSAGE –"
    if re.match(r'^PASSAGE[\s–-]*$', line_stripped, re.IGNORECASE):
        return True
    
    return False

def get_section_from_header(line):
    """Extract section name from header line - maps to Prisma SectionType enum (JavaScript logic)"""
    line_lower = line.lower().strip()
    
    # Exact JavaScript logic
    if 'english' in line_lower or 'language' in line_lower:
        return 'ENGLISH'
    elif 'gk' in line_lower or 'general knowledge' in line_lower or 'current affairs' in line_lower:
        return 'GK_CA'
    elif 'legal reasoning' in line_lower:
        return 'LEGAL_REASONING'
    elif 'logical reasoning' in line_lower:
        return 'LOGICAL_REASONING'
    elif 'quantitative' in line_lower or 'mathematics' in line_lower:
        return 'QUANTITATIVE_TECHNIQUES'
    
    return 'ENGLISH'  # Default

def is_question_start(line):
    """Check if line starts a new question using robust patterns"""
    line_stripped = line.strip()
    
    # Skip watermarks and headers
    if is_watermark_or_header(line):
        return False
    
    # Skip if it's a section or passage header
    if is_section_header(line) or is_passage_header(line):
        return False
    
    # Enhanced question patterns - more comprehensive
    patterns = [
        r'^\d{1,3}\.\s+',           # 1. Question text (1-3 digits)
        r'^\d{1,3}\)\s+',           # 1) Question text
        r'^\(\d{1,3}\)\s+',         # (1) Question text
        r'^\d{1,3}:\s+',            # 1: Question text
        r'^\d{1,3}-\s+',            # 1- Question text
        r'^\d{1,3}\.\d+\s+',        # 1.1 Question text
        r'^\d{1,3}-\d+\s+',         # 1-1 Question text
        r'^Q\d{1,3}\.?\s*',         # Q1. Question text
        r'^Question\s+\d{1,3}',     # Question 1
        r'^\d{1,3}\.\d+\.\d+\s+',   # 1.1.1 Question text
        r'^\d{1,3}\s+',             # 1 Question text (space after number)
        r'^\d{1,3}\.\d*[a-zA-Z]',   # 1.a, 1.b, etc.
        r'^\d{1,3}\s*[\.\):\-]\s*', # More flexible separators
    ]
    
    for pattern in patterns:
        if re.match(pattern, line_stripped):
            return True
    
    # Check if line starts with a number followed by text (more flexible)
    if re.match(r'^\d{1,3}[\.\):\-\s]+[A-Za-z]', line_stripped):
        return True
    
    # Additional check for lines that start with numbers and contain question-like content
    if re.match(r'^\d{1,3}', line_stripped) and len(line_stripped) > 5:
        # Check if it contains question words or patterns
        question_indicators = [
            'what', 'which', 'who', 'when', 'where', 'why', 'how',
            'choose', 'select', 'identify', 'determine', 'find',
            'correct', 'incorrect', 'true', 'false', 'best', 'most',
            'least', 'except', 'not', 'all', 'some', 'none',
            'statement', 'assertion', 'reason', 'conclusion',
            'assumption', 'premise', 'inference', 'implication',
            'according', 'based', 'given', 'provided', 'suppose',
            'if', 'then', 'unless', 'only', 'always', 'never',
            'sometimes', 'often', 'rarely', 'usually',
            'the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been',
            'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would',
            'can', 'could', 'should', 'may', 'might', 'must'
        ]
        line_lower = line_stripped.lower()
        if any(indicator in line_lower for indicator in question_indicators):
            return True
        
        # Also check for lines that end with question marks
        if line_stripped.endswith('?'):
            return True
        
        # Check for lines that contain option patterns (A), (B), etc.
        if re.search(r'\([A-E]\)', line_stripped):
            return True
        
        # More aggressive: if line starts with number and has reasonable length, consider it
        if len(line_stripped) > 15 and len(line_stripped) < 200:
            return True
    
    return False

def extract_question_text(line):
    """Extract question text by removing question number"""
    patterns = [
        r'^\d+\.\s+',
        r'^\d+\)\s+',
        r'^\(\d+\)\s+',
        r'^\d+:\s+',
        r'^\d+-\s+',
        r'^\d+\.\d+\s+',
        r'^\d+-\d+\s+',
    ]
    
    for pattern in patterns:
        line = re.sub(pattern, '', line)
    
    return line.strip()

def contains_options(line):
    """Check if line contains option patterns"""
    option_patterns = [
        r'\([A-D]\)',       # (A), (B), etc.
        r'[A-D]\)',         # A), B), etc.
        r'[A-D]\.',         # A., B., etc.
        r'[A-D]\s',         # A , B , etc.
    ]
    
    return any(re.search(pattern, line) for pattern in option_patterns)

def extract_all_options(line):
    """Extract all options from a line using robust patterns"""
    options = []
    line = line.strip()
    
    # Skip if it's a watermark or header
    if is_watermark_or_header(line):
        return options
    
    # Pattern 1: Handle format like "(A) option1 (B) option2 (C) option3 (D) option4"
    pattern1 = r'\(([A-E])\)\s*([^\(]+?)(?=\s*\([A-E]\)|$)'
    matches = re.findall(pattern1, line)
    
    if matches:
        options = [match[1].strip() for match in matches if match[1].strip()]
        if options:
            return options
    
    # Pattern 2: Handle format like "A) option1 B) option2 C) option3 D) option4"
    pattern2 = r'([A-E])\)\s*([^A-E]+?)(?=\s*[A-E]\)|$)'
    matches = re.findall(pattern2, line)
    
    if matches:
        options = [match[1].strip() for match in matches if match[1].strip()]
        if options:
            return options
    
    # Pattern 3: Handle format like "A. option1 B. option2 C. option3 D. option4"
    pattern3 = r'([A-E])\.\s*([^A-E]+?)(?=\s*[A-E]\.|$)'
    matches = re.findall(pattern3, line)
    
    if matches:
        options = [match[1].strip() for match in matches if match[1].strip()]
        if options:
            return options
    
    # Pattern 4: Handle format like "A option1 B option2 C option3 D option4"
    pattern4 = r'([A-E])\s+([^A-E]+?)(?=\s+[A-E]\s|$)'
    matches = re.findall(pattern4, line)
    
    if matches:
        options = [match[1].strip() for match in matches if match[1].strip()]
        if options:
            return options
    
    # Pattern 5: Handle format like "200 (B) 160 (C) 40 (D) 110"
    pattern5 = r'(\d+|\w+)\s*\(([A-E])\)\s*(\d+|\w+)'
    matches = re.findall(pattern5, line)
    
    if matches:
        for match in matches:
            if match[0]:  # First option (without letter)
                options.append(match[0].strip())
            if match[2]:  # Second option (with letter)
                options.append(match[2].strip())
        
        if options:
            return options
    
    # Pattern 6: Handle multi-line options (look for single options on their own line)
    if re.match(r'^[A-E][\)\.]\s*', line):
        # This is a single option on its own line
        option_text = re.sub(r'^[A-E][\)\.]\s*', '', line).strip()
        if option_text:
            return [option_text]
    
    # Pattern 7: Simple space-separated options (fallback)
    words = line.split()
    if 2 <= len(words) <= 10:  # More flexible range
        if all(re.match(r'^[\d\w\-\.]+$', word) and len(word) < 30 for word in words):
            return words
    
    return options

def contains_image_reference(line):
    """Check if line contains image references"""
    image_patterns = [
        r'figure\s+\d+',
        r'fig\.\s*\d+',
        r'image\s+\d+',
        r'img\s+\d+',
        r'see\s+figure',
        r'refer\s+to\s+figure',
    ]
    
    return any(re.search(pattern, line, re.IGNORECASE) for pattern in image_patterns)

def parse_questions_from_text(text):
    """Parse questions from extracted text with robust section, passage, and question handling"""
    # Pre-process text to remove watermarks and clean up
    lines = []
    for line in text.split('\n'):
        line = line.strip()
        if line and not is_watermark_or_header(line):
            lines.append(line)
    
    # print(f"DEBUG: Processing {len(lines)} lines after watermark filtering")
    
    # Data structures to maintain hierarchy
    sections = []
    current_section = None
    current_passage = None
    current_question = None
    question_number = 1
    
    for i, line in enumerate(lines):
        # Detect section headers
        if is_section_header(line):
            # Save current question if exists
            if current_question:
                if current_passage:
                    current_passage['questions'].append(current_question)
                else:
                    if current_section:
                        current_section['questions'].append(current_question)
                    else:
                        # Create default section if none exists
                        current_section = {
                            'title': 'DEFAULT',
                            'section': 'ENGLISH',
                            'passages': [],
                            'questions': []
                        }
                        current_section['questions'].append(current_question)
                current_question = None
                question_number += 1
            
            # Start new section
            current_section = {
                'title': line,
                'section': get_section_from_header(line),
                'passages': [],
                'questions': []
            }
            sections.append(current_section)
            current_passage = None
            continue
        
        # Detect passage headers
        if is_passage_header(line):
            # Save current question if exists
            if current_question:
                if current_passage:
                    current_passage['questions'].append(current_question)
                else:
                    if current_section:
                        current_section['questions'].append(current_question)
                current_question = None
                question_number += 1
            
            # Start new passage
            current_passage = {
                'title': line,
                'text': '',
                'questions': []
            }
            if current_section:
                current_section['passages'].append(current_passage)
            else:
                # Create default section if none exists
                current_section = {
                    'title': 'DEFAULT',
                    'section': 'ENGLISH',
                    'passages': [],
                    'questions': []
                }
                sections.append(current_section)
                current_section['passages'].append(current_passage)
            continue
        
        # Detect question start
        if is_question_start(line):
            # Save previous question if exists
            if current_question:
                if current_passage:
                    current_passage['questions'].append(current_question)
                elif current_section:
                    current_section['questions'].append(current_question)
                question_number += 1
            
            # print(f"DEBUG: Found question {question_number}: '{line[:50]}...'")
            
            # Start new question
            current_question = {
                'questionNumber': question_number,
                'questionText': extract_question_text(line),
                'section': current_section['section'] if current_section else 'ENGLISH',
                'questionType': 'OPTIONS',
                'optionType': 'SINGLE',
                'options': [],
                'correctAnswers': [],
                'positiveMarks': 1.0,
                'negativeMarks': -0.25,
                'isComprehension': bool(current_passage),
                'isTable': False,
                'imageUrls': []
            }
            continue
        
        # If we have a current question, process the line
        if current_question:
            # Check if this line contains options
            if contains_options(line):
                options = extract_all_options(line)
                if options:
                    current_question['options'].extend(options)
            else:
                # If no options found, append to question text
                if line and not is_section_header(line) and not is_question_start(line) and not is_passage_header(line):
                    if contains_image_reference(line):
                        current_question['questionText'] += '\n' + line
                    else:
                        current_question['questionText'] += ' ' + line
        elif current_passage and not is_question_start(line) and not is_section_header(line) and not is_passage_header(line):
            # Add text to current passage
            current_passage['text'] += ' ' + line
        elif not current_question and not current_passage and not is_section_header(line) and not is_passage_header(line):
            # More aggressive fallback: if we have a line that looks like it could be a question, try to extract it
            if (re.match(r'^\d+[\.\):\-\s]*', line) and len(line) > 10 and 
                not re.match(r'^[A-E][\)\.]\s*', line) and  # Not an option
                not re.match(r'^[A-E]\s+', line)):  # Not an option without punctuation
                # print(f"DEBUG: Fallback question detection: '{line[:50]}...'")
                # This might be a question that wasn't detected properly
                current_question = {
                    'questionNumber': question_number,
                    'questionText': extract_question_text(line),
                    'section': current_section['section'] if current_section else 'ENGLISH',
                    'questionType': 'OPTIONS',
                    'optionType': 'SINGLE',
                    'options': [],
                    'correctAnswers': [],
                    'positiveMarks': 1.0,
                    'negativeMarks': -0.25,
                    'isComprehension': bool(current_passage),
                    'isTable': False,
                    'imageUrls': []
                }
                question_number += 1
    
    # Save the last question
    if current_question:
        if current_passage:
            current_passage['questions'].append(current_question)
        elif current_section:
            current_section['questions'].append(current_question)
    
    # Flatten all questions into a single list while maintaining order
    all_questions = []
    for section in sections:
        # Add section-level questions
        for question in section['questions']:
            all_questions.append(question)
        
        # Add passage-level questions
        for passage in section['passages']:
            for question in passage['questions']:
                # Add passage text to question if it's a comprehension question
                if passage['text']:
                    question['questionText'] = passage['text'].strip() + '\n\n' + question['questionText']
                    question['isComprehension'] = True
                all_questions.append(question)
    
    # Post-process questions to clean up and validate
    cleaned_questions = []
    for question in all_questions:
        # Clean up question text
        question['questionText'] = re.sub(r'\s+', ' ', question['questionText']).strip()
        
        # Clean up options
        question['options'] = [opt.strip() for opt in question['options'] if opt.strip()]
        
        # Remove duplicate options
        question['options'] = list(dict.fromkeys(question['options']))
        
        # More lenient validation - include questions even without options
        if question['questionText'] and len(question['questionText'].strip()) > 10:
            # If no options found, create placeholder options
            if not question['options'] or len(question['options']) == 0:
                question['options'] = ['Option A', 'Option B', 'Option C', 'Option D']
                # print(f"DEBUG: Added placeholder options for question: {question['questionText'][:50]}...")
            
        # Set first option as correct answer (placeholder)
            question['correctAnswers'] = [question['options'][0]]
            cleaned_questions.append(question)
    
    # Renumber questions to maintain sequence
    for i, question in enumerate(cleaned_questions):
        question['questionNumber'] = i + 1
    
    # If all questions are in one section, try to distribute them more intelligently
    summary = generate_question_summary(cleaned_questions)
    if len(summary) == 1 and len(cleaned_questions) >= 4:
        # print(f"DEBUG: All questions in one section, attempting intelligent distribution...")
        
        # Try to find natural section boundaries by looking for question patterns
        # that might indicate section changes
        sections = ['ENGLISH', 'GK_CA', 'LEGAL_REASONING', 'QUANTITATIVE_TECHNIQUES']
        questions_per_section = len(cleaned_questions) // 4
        
        # Distribute questions with some overlap to ensure we don't miss section boundaries
        for i, question in enumerate(cleaned_questions):
            # Use a more gradual transition between sections
            if i < questions_per_section:
                question['section'] = 'ENGLISH'
            elif i < questions_per_section * 2:
                question['section'] = 'GK_CA'
            elif i < questions_per_section * 3:
                question['section'] = 'LEGAL_REASONING'
            else:
                question['section'] = 'QUANTITATIVE_TECHNIQUES'
            
            # print(f"DEBUG: Question {i+1} assigned to {question['section']}")
    
    # print(f"DEBUG: Final question count: {len(cleaned_questions)}")
    # print(f"DEBUG: Questions by section: {generate_question_summary(cleaned_questions)}")
    
    return cleaned_questions

def generate_question_summary(questions):
    """Generate summary of questions by section"""
    summary = {}
    
    for question in questions:
        section = question['section']
        if section not in summary:
            summary[section] = 0
        summary[section] += 1
    
    return summary

def main():
    if len(sys.argv) != 6:
        print(json.dumps({
            'success': False,
            'error': 'Usage: python process_text.py <text_path> <title> <description> <duration> <totalMarks>'
        }))
        sys.exit(1)
    
    text_path = sys.argv[1]
    title = sys.argv[2]
    description = sys.argv[3]
    duration = int(sys.argv[4])
    totalMarks = int(sys.argv[5])
    
    try:
        # Read text from file
        with open(text_path, 'r', encoding='utf-8') as f:
            text = f.read()
        
        if not text.strip():
            print(json.dumps({
                'success': False,
                'error': 'No text content found'
            }))
            sys.exit(1)
        
        # Parse questions from text
        questions = parse_questions_from_text(text)
        
        if not questions:
            print(json.dumps({
                'success': False,
                'error': 'No questions found in text'
            }))
            sys.exit(1)
        
        # Generate summary
        summary = generate_question_summary(questions)
        
        # Create test data
        test_data = {
            'title': title,
            'description': description,
            'duration': duration,
            'totalMarks': totalMarks,
            'questions': questions
        }
        
        result = {
            'success': True,
            'message': f'Successfully extracted {len(questions)} questions',
            'testData': test_data,
            'summary': summary
        }
        
        print(json.dumps(result))
        
    except Exception as e:
        print(json.dumps({
            'success': False,
            'error': f'Error processing text: {str(e)}'
        }))
        sys.exit(1)

if __name__ == '__main__':
    main()
