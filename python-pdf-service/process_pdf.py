#!/usr/bin/env python3
"""
Standalone Python script for processing PDF files
Can be called from Next.js API routes
"""
import sys
import json
import fitz
import re
from pathlib import Path

def is_watermark_or_header(line):
    """Check if line is a watermark, header, or footer that should be ignored"""
    line_lower = line.lower().strip()
    
    # Common watermark patterns
    watermark_patterns = [
        r'page\s+\d+',
        r'www\.\w+\.com',
        r'http[s]?://\w+',
        r'copyright',
        r'all rights reserved',
        r'confidential',
        r'draft',
        r'preliminary',
        r'version\s+\d+',
        r'generated by',
        r'created by',
        r'pdf',
        r'document',
        r'file',
        r'date:',
        r'time:',
        r'printed on',
        r'printed at',
        r'page \d+ of \d+',
        r'^\d+$',  # Just page numbers
        r'^[^\w]*$',  # Only special characters
        r't\.i\.m\.e\.',  # T.I.M.E. watermark
        r'kabirjaiswal',  # Specific watermark
        r'disclaimer',
        r'instructions',
        r'general instructions',
        r'read the following',
        r'note:',
        r'caution:',
        r'warning:',
    ]
    
    # Check for watermark patterns
    for pattern in watermark_patterns:
        if re.search(pattern, line_lower):
            return True
    
    # Check for very short lines that are likely headers/footers
    if len(line.strip()) < 3:
        return True
    
    # Check for lines with only numbers or special characters
    if re.match(r'^[\d\s\-_\.]+$', line):
        return True
    
    return False

def is_section_header(line):
    """Check if line is a section header using JavaScript logic"""
    line_stripped = line.strip()
    line_lower = line_stripped.lower()
    
    # Skip if it's a watermark
    if is_watermark_or_header(line):
        return False
    
    # JavaScript section keywords
    section_keywords = [
        'english', 'language', 'gk', 'general knowledge', 'current affairs',
        'legal reasoning', 'logical reasoning', 'quantitative', 'mathematics'
    ]
    
    # Check if line contains section keywords AND (length < 50 OR contains 'section')
    for keyword in section_keywords:
        if keyword in line_lower:
            if len(line_stripped) < 50 or 'section' in line_lower:
                return True
    
    return False

def get_section_from_header(line):
    """Extract section name from header line - maps to Prisma SectionType enum (JavaScript logic)"""
    line_lower = line.lower().strip()
    
    # Exact JavaScript logic
    if 'english' in line_lower or 'language' in line_lower:
        return 'ENGLISH'
    elif 'gk' in line_lower or 'general knowledge' in line_lower or 'current affairs' in line_lower:
        return 'GK_CA'
    elif 'legal reasoning' in line_lower:
        return 'LEGAL_REASONING'
    elif 'logical reasoning' in line_lower:
        return 'LOGICAL_REASONING'
    elif 'quantitative' in line_lower or 'mathematics' in line_lower:
        return 'QUANTITATIVE_TECHNIQUES'
    
    return 'ENGLISH'  # Default

def is_question_start(line):
    """Check if line starts a new question"""
    line_stripped = line.strip()
    
    # Skip watermarks and headers
    if is_watermark_or_header(line):
        return False
    
    # Enhanced question patterns
    patterns = [
        r'^\d+\.\s+',           # 1. Question text
        r'^\d+\)\s+',           # 1) Question text
        r'^\(\d+\)\s+',         # (1) Question text
        r'^\d+:\s+',            # 1: Question text
        r'^\d+-\s+',            # 1- Question text
        r'^\d+\.\d+\s+',        # 1.1 Question text
        r'^\d+-\d+\s+',         # 1-1 Question text
        r'^Q\d+\.?\s*',         # Q1. Question text
        r'^Question\s+\d+',     # Question 1
        r'^\d+\.\d+\.\d+\s+',   # 1.1.1 Question text
    ]
    
    for pattern in patterns:
        if re.match(pattern, line_stripped):
            return True
    
    # Check if line starts with a number followed by text (more flexible)
    if re.match(r'^\d+[\.\):\-\s]+[A-Za-z]', line_stripped):
        return True
    
    return False

def extract_question_text(line):
    """Extract question text by removing question number"""
    patterns = [
        r'^\d+\.\s+',
        r'^\d+\)\s+',
        r'^\(\d+\)\s+',
        r'^\d+:\s+',
        r'^\d+-\s+',
        r'^\d+\.\d+\s+',
        r'^\d+-\d+\s+',
    ]
    
    for pattern in patterns:
        line = re.sub(pattern, '', line)
    
    return line.strip()

def contains_options(line):
    """Check if line contains option patterns"""
    option_patterns = [
        r'\([A-D]\)',       # (A), (B), etc.
        r'[A-D]\)',         # A), B), etc.
        r'[A-D]\.',         # A., B., etc.
        r'[A-D]\s',         # A , B , etc.
    ]
    
    return any(re.search(pattern, line) for pattern in option_patterns)

def extract_all_options(line):
    """Extract all options from a line"""
    options = []
    line = line.strip()
    
    # Skip if it's a watermark or header
    if is_watermark_or_header(line):
        return options
    
    # Pattern 1: Handle format like "A) option1 B) option2 C) option3 D) option4"
    pattern1 = r'([A-D])\)\s*([^A-D]+?)(?=\s*[A-D]\)|$)'
    matches = re.findall(pattern1, line)
    
    if matches:
        options = [match[1].strip() for match in matches if match[1].strip()]
        if options:
            return options
    
    # Pattern 2: Handle format like "(A) option1 (B) option2 (C) option3 (D) option4"
    pattern2 = r'\(([A-D])\)\s*([^\(]+?)(?=\s*\([A-D]\)|$)'
    matches = re.findall(pattern2, line)
    
    if matches:
        options = [match[1].strip() for match in matches if match[1].strip()]
        if options:
            return options
    
    # Pattern 3: Handle format like "A. option1 B. option2 C. option3 D. option4"
    pattern3 = r'([A-D])\.\s*([^A-D]+?)(?=\s*[A-D]\.|$)'
    matches = re.findall(pattern3, line)
    
    if matches:
        options = [match[1].strip() for match in matches if match[1].strip()]
        if options:
            return options
    
    # Pattern 4: Handle format like "200 (B) 160 (C) 40 (D) 110"
    pattern4 = r'(\d+|\w+)\s*\(([A-D])\)\s*(\d+|\w+)'
    matches = re.findall(pattern4, line)
    
    if matches:
        for match in matches:
            if match[0]:  # First option (without letter)
                options.append(match[0].strip())
            if match[2]:  # Second option (with letter)
                options.append(match[2].strip())
        
        if options:
            return options
    
    # Pattern 5: Handle format like "A option1 B option2 C option3 D option4"
    pattern5 = r'([A-D])\s+([^A-D]+?)(?=\s+[A-D]\s|$)'
    matches = re.findall(pattern5, line)
    
    if matches:
        options = [match[1].strip() for match in matches if match[1].strip()]
        if options:
            return options
    
    # Pattern 6: Simple space-separated options (fallback)
    words = line.split()
    if 2 <= len(words) <= 10:  # More flexible range
        if all(re.match(r'^[\d\w\-\.]+$', word) and len(word) < 30 for word in words):
            return words
    
    return options

def contains_image_reference(line):
    """Check if line contains image references"""
    image_patterns = [
        r'figure\s+\d+',
        r'fig\.\s*\d+',
        r'image\s+\d+',
        r'img\s+\d+',
        r'see\s+figure',
        r'refer\s+to\s+figure',
    ]
    
    return any(re.search(pattern, line, re.IGNORECASE) for pattern in image_patterns)

def extract_text_from_pdf(pdf_path):
    """Extract text from PDF using PyMuPDF"""
    try:
        doc = fitz.open(pdf_path)
        text = ""
        
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            text += page.get_text()
            text += "\n"  # Add newline between pages
        
        doc.close()
        return text
    except Exception as e:
        raise Exception(f"Failed to extract text from PDF: {str(e)}")

def parse_questions_from_text(text):
    """Parse questions from extracted text with improved watermark filtering and sequence maintenance"""
    questions = []
    
    # Pre-process text to remove watermarks and clean up
    lines = []
    for line in text.split('\n'):
        line = line.strip()
        if line and not is_watermark_or_header(line):
            lines.append(line)
    
    current_question = None
    question_number = 1
    current_section = 'ENGLISH'
    comprehension_passage = ''
    in_options = False
    consecutive_empty_lines = 0
    
    for i, line in enumerate(lines):
        # Skip empty lines but track them
        if not line:
            consecutive_empty_lines += 1
            if consecutive_empty_lines > 2:  # Too many empty lines, likely end of section
                if current_question:
                    questions.append(current_question)
                    current_question = None
                    question_number += 1
                in_options = False
            continue
        else:
            consecutive_empty_lines = 0
        
        # Detect section headers
        if is_section_header(line):
            # Save current question if exists
            if current_question:
                questions.append(current_question)
                question_number += 1
            
            current_section = get_section_from_header(line)
            comprehension_passage = ''
            in_options = False
            current_question = None
            continue
        
        # Detect comprehension passages (long text before questions)
        if (not current_question and 
            not is_question_start(line) and 
            not is_section_header(line) and 
            len(line) > 50 and
            not contains_options(line)):
            comprehension_passage += line + ' '
            continue
        
        # Detect question start
        if is_question_start(line):
            # Save previous question if exists
            if current_question:
                questions.append(current_question)
                question_number += 1
            
            # Start new question
            current_question = {
                'questionNumber': question_number,
                'questionText': extract_question_text(line),
                'section': current_section,
                'questionType': 'OPTIONS',
                'optionType': 'SINGLE',
                'options': [],
                'correctAnswers': [],
                'positiveMarks': 1.0,
                'negativeMarks': -0.25,
                'isComprehension': bool(comprehension_passage),
                'isTable': False,
                'imageUrls': []
            }
            
            # Add comprehension passage if it exists
            if comprehension_passage:
                current_question['questionText'] = comprehension_passage.strip() + '\n\n' + current_question['questionText']
                comprehension_passage = ''
            
            in_options = False
            continue
        
        # If we have a current question, process the line
        if current_question:
            # Check if this line contains options
            if contains_options(line):
                options = extract_all_options(line)
                if options:
                    current_question['options'].extend(options)
                    in_options = True
            elif in_options and not is_question_start(line) and not is_section_header(line):
                # If we were in options mode and this line doesn't start a new question,
                # it might be a continuation of options or the end of options
                if line and len(line) < 100:  # Short line might be an option
                    # Check if it looks like an option
                    if re.match(r'^[A-D][\)\.]\s*', line) or re.match(r'^\([A-D]\)\s*', line):
                        current_question['options'].append(line)
                    else:
                        in_options = False
                else:
                    in_options = False
            else:
                # If no options found, append to question text
                if line and not is_section_header(line) and not is_question_start(line):
                    if contains_image_reference(line):
                        current_question['questionText'] += '\n' + line
                    else:
                        current_question['questionText'] += ' ' + line
                    in_options = False
    
    # Add the last question
    if current_question:
        questions.append(current_question)
    
    # Post-process questions to clean up and validate
    cleaned_questions = []
    for question in questions:
        # Clean up question text
        question['questionText'] = re.sub(r'\s+', ' ', question['questionText']).strip()
        
        # Clean up options
        question['options'] = [opt.strip() for opt in question['options'] if opt.strip()]
        
        # Remove duplicate options
        question['options'] = list(dict.fromkeys(question['options']))
        
        # More lenient validation - include questions even without options
        if question['questionText'] and len(question['questionText'].strip()) > 10:
            # If no options found, create placeholder options
            if not question['options'] or len(question['options']) == 0:
                question['options'] = ['Option A', 'Option B', 'Option C', 'Option D']
            
            # Set first option as correct answer (placeholder)
            question['correctAnswers'] = [question['options'][0]]
            cleaned_questions.append(question)
    
    # Renumber questions to maintain sequence
    for i, question in enumerate(cleaned_questions):
        question['questionNumber'] = i + 1
    
    # If all questions are in one section, try to distribute them more intelligently
    summary = generate_question_summary(cleaned_questions)
    if len(summary) == 1 and len(cleaned_questions) >= 4:
        print(f"DEBUG: All questions in one section, attempting intelligent distribution...")
        
        # Try to find natural section boundaries by looking for question patterns
        # that might indicate section changes
        sections = ['ENGLISH', 'GK_CA', 'LEGAL_REASONING', 'QUANTITATIVE_TECHNIQUES']
        questions_per_section = len(cleaned_questions) // 4
        
        # Distribute questions with some overlap to ensure we don't miss section boundaries
        for i, question in enumerate(cleaned_questions):
            # Use a more gradual transition between sections
            if i < questions_per_section:
                question['section'] = 'ENGLISH'
            elif i < questions_per_section * 2:
                question['section'] = 'GK_CA'
            elif i < questions_per_section * 3:
                question['section'] = 'LEGAL_REASONING'
            else:
                question['section'] = 'QUANTITATIVE_TECHNIQUES'
            
            print(f"DEBUG: Question {i+1} assigned to {question['section']}")
    
    return cleaned_questions

def generate_question_summary(questions):
    """Generate summary of questions by section"""
    summary = {}
    
    for question in questions:
        section = question['section']
        if section not in summary:
            summary[section] = 0
        summary[section] += 1
    
    return summary

def main():
    if len(sys.argv) != 6:
        print(json.dumps({
            'success': False,
            'error': 'Usage: python process_pdf.py <pdf_path> <title> <description> <duration> <totalMarks>'
        }))
        sys.exit(1)
    
    pdf_path = sys.argv[1]
    title = sys.argv[2]
    description = sys.argv[3]
    duration = int(sys.argv[4])
    totalMarks = int(sys.argv[5])
    
    try:
        # Extract text from PDF
        text = extract_text_from_pdf(pdf_path)
        
        if not text.strip():
            print(json.dumps({
                'success': False,
                'error': 'No text found in PDF'
            }))
            sys.exit(1)
        
        # Parse questions from text
        questions = parse_questions_from_text(text)
        
        if not questions:
            print(json.dumps({
                'success': False,
                'error': 'No questions found in PDF'
            }))
            sys.exit(1)
        
        # Generate summary
        summary = generate_question_summary(questions)
        
        # Create test data
        test_data = {
            'title': title,
            'description': description,
            'duration': duration,
            'totalMarks': totalMarks,
            'questions': questions
        }
        
        result = {
            'success': True,
            'message': f'Successfully extracted {len(questions)} questions',
            'testData': test_data,
            'summary': summary
        }
        
        print(json.dumps(result))
        
    except Exception as e:
        print(json.dumps({
            'success': False,
            'error': f'Error processing PDF: {str(e)}'
        }))
        sys.exit(1)

if __name__ == '__main__':
    main()
